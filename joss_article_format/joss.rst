Summary
=======

``MWInv`` is a C++ library that programs microwave inversion based on
the physics of electromagnetic scattering. It programs the configurable
setup of microwave antenna-based imaging of a region with a
heterogeneous dielectric profile. The forward problem of electromagnetic
wave propagation is based on Maxwell's Equations, which is implemented
using the Finite Element Method Library ``MFEM`` [8].

The simuation region is discretised for a Finite Element approach, 
using ``Gmsh`` [9] to programmatically generate the
mesh based on user configurations. The forward solver is used to
evaluate the field produced by an estimate of the dielectric profile of
the region being imaged by the antenna array. This response is then
compared with any reference electric field data provided by the user.
This comparison allows updating the estimate dielectric profile using an
optimization approach. The optimization process is implemented by using
``dlib`` [10], where the difference between
reference data and the data generated by the guess profile are
iteratively reduced. With the combination of such a system, the complex
permittivity profile of the imaged region is reconstructed.

Statement of Need
=================

Inverse problems are abundant in real world applications. However, due
to the specifity of the forward problems associated with them, they are
usually very application specific. ``MWInv`` attempts to create a
general purpose electromagnetic inverse solver using the versatility of
``MFEM`` library and the varied options available in ``dlib`` to recast
the inverse problem as an optimization problem. Together, the library
allows for a very diverse set of electromagnetic inverse problems to be
solved.

Physics and Computational Aspects of Microwave Inversion
========================================================

Setup of Microwave Inversion
----------------------------

The electromagnetic inverse problem is the problem to reconstruct the
electromagnetic properties of an arbitrary region being exposed to
electromagnetic fields. There is, in most cases, a bounded domain
surrounded by an array of antennas that are used as both sources and
receivers of electromagnetic fields. There are two possibilities for how
the antennas are configured. One method sets all antennas as
transrecievers. This allows a tomography like setup, where one antenna
acts as a source and the remaining antennas act as receivers at a time.
This repeats until all antennas have acted as a source. The other method
is to have two separate arrays, one just of sources and other just of
receivers. This is a more intensive setup that is more realisable as
just numerical experiments, however it has the potential to give more
control over the source field.

The antennas are numerically modelled as point dipole sources. They are
ususally placed around the imaging domain such that their near field
range is not interacting with the domain, to ensure far field
approxmiation to be valid so only plane waves interact with the
hetereogeneous medium. This is essential to ensure that the background
field is numerically known, and hence the inverse reconstruction is
possible. The antennas operate in the microwave spectrum of
electromagnetic frequency ranges (300 MHz - 300 GHz). Although,
specifications for applications such as medical imaging exist at around
1 GHz.

The Inversion Loop
------------------

The Initial Model
~~~~~~~~~~~~~~~~~

Once the receiver data is collected, the reconstruction loop begins. An
initial guess model of the dielectric profile is made using the
inversion method in use. In the method used in this work, the Distorted
Born Iterative Method (DBIM), the dielectric profile of the scattering
heterogeneity is considered to be weak. This allows the initial guess to
start from a homogeneous medium starting with the same complex
permittivity as the background medium. To ensure that the Born
approximation is valid for all microwave imaging operations, sometimes
the background medium of the experimental setup is altered so that the
difference in background to heterogeneities is not that high.

Iterative Inversion
~~~~~~~~~~~~~~~~~~~

This initial model allows the solving of the forward problem assuming
that it explains the data. An error is calculated between the measured
data and a simulated response. Using this information, and an
optimization strategy, the guess model is updated. This updated model's
response is now evaluated, and subsequently its corresponding error.
This iterative update of the estimate model of complex permittivity is
continued until convergence, i.e. error margins are reached, and/or a
predefined maximum limit on the number of iterations is reached.

The Forward Problem Formulation
-------------------------------

The estimate model's electromagnetic response to a source background
field is evaluated at each iteration. This is associated with the
forward problem of electromagnetics, based on the wave equation in
frequency domain:

.. math::

    \nabla E(\mathbf{r}_i, \mathbf{r}) + \omega^2 \mu_0 \epsilon_0 \epsilon_r(\mathbf{r}) E(\mathbf{r}_i, \mathbf{r}) = j \omega \mu_0 J(\mathbf{r}_i)

This equation describes how the electric field :math:`E(r_i,r)` varies
in space at each location :math:`r` based on the current source
:math:`J` located at :math:`r_i`. The :math:`\nabla` operator denotes
the space derivative, and :math:`-\omega^2` describes the time
derivative in frequency domain.

The part where the equation carries information of the medium parameters
are :math:`\mu` and :math:`\epsilon`, the permeability and permittivity
respectively. In this work, FEM is used to solve this PDE.

The FEM Approach
----------------

The FEM approach allows spatial discretisation using basis functions.
For electromagnetics problems, the Nedlec basis functions are optimal,
since they capture the rotational and vectorial aspects of the
electromagnetic fields. In FEM, the equation becomes for each single
element :math:`n`:

.. math::

   \left( \mathbf{K}^n - \omega^2 \mu_0 \epsilon_0 \epsilon_r^n \mathbf{M}^n + \mathbf{D}^n \right) \mathbf{e}_i^n = -j \omega \mu_0 \mathbf{f}_i^n

where :math:`K` is the stiffness matrix, related to the spatial double
derivative, and :math:`M` refers to the Mass matrix, relating to the
time derivative. :math:`e_i` is the electric field values, which is the
solution of the system due to the usage of basis functions. :math:`D` is
the boundary condition term, and :math:`f` is the term to represent
sources.This equation becomes condensed into:

.. math::

    \mathbf{S}\mathbf{E} = -j \omega \mu_0 \mathbf{F}

For a system of multiple sources at the same time, the term :math:`F`
has only a single column vector with all source contributions. However,
in the single source - multiple receiver setup, we have a multiple RHS
global set of linear systems. These can still be evaluated one at a time
corresponding to one source, then the results can be combined.

The Inverse Problem Formulation and the Advantage from FEM
----------------------------------------------------------

The inverse problem hinges on the need to figure out the field scattered
by the region's heterogeneities. This means that a solution of the wave
equation for the scattered field is required. The solution for the
scattered field :math:`E_s` depending on the heterogeneities
:math:`\delta` is given by:

.. math::

    E_{\vec{s}}(\vec{r}, r_j) = \frac{j \omega \epsilon_0}{I} \sum_{n=1}^{N} \delta S_n E_{\theta}(\vec{r}_n, r_j) E_{\phi}(\vec{r}_n, r_j)

It is noted that the terms in the equation are already available to us
if the forward system is solved by FEM. Recasting the scattered field
term into FEM-relevant matrices:

.. math::


   \iint_{S_n} E_b(\vec{r}_i; \vec{r}_j) \cdot E_b(\vec{r}_j; \vec{r}_j) dS = \iint_{S_n} \left( \sum_{p=1}^{P_n} \Phi_p^n (\vec{r}) e_{p,i}^n  \right)   \left(  \sum_{q=1}^{P_n} \Phi_p^n (\vec{r}) e_{q,j}^n  \right) dS = (e_i^n)^T M_e^n e_j^n

we see that for each element, we can already form a linear system
:math:`Ax = b` for the scattered field equation. Here, :math:`b` will be
the difference between the field reference data and the evaluated field
from the estimate. This makes :math:`Ax` correspond to just the scatter
field response from the heterogeneities, where :math:`x` is the contrast
from heterogeneities, and :math:`A` captures the behaviour of wave
propagation between source and receiver.

The size of :math:`A` is :math:`X\times Y`, wherer :math:`X` corresponds
to the number of pairs of sources and receivers, and :math:`Y`
corresponds to the number of degrees of freedom in the imaging region.

Solving the Inverse Problem
---------------------------

The inverse equation is iteratively solved, starting from the Born
approximation. The fact that this specific formulation is “Distorted”
comes from the fact that the :math:`A` matrix is always being updated on
each iteration. This formulation is more expensive to perform using
alternate methods of forward solvers, since there we need to
specifically calculate the :math:`A` matrix on each iteration on top of
doing the regular forward solving. This makes the formulation used by
[@lu2020] very attractive computationally.

Since the inverse linear system is complex valued (due to the
time-harmonic equation, the source formulation, and the complex
permittivity), the problem is often recasted into a real valued
formulation by separating the real and imaginary components of the
system. Hence, the equation :math:`Ax=b` of the inverse system becomes:

.. math::


   \mathbf{\hat A} \mathbf{\hat \delta_{\epsilon}} = b \Leftrightarrow 
   \begin{bmatrix}
   \mathbf{\hat A_{\mathcal{R}}} & \mathbf{\hat A_{\mathcal{I}}} \\
   \mathbf{\hat A_{\mathcal{I}}} & -\mathbf{\hat A_{\mathcal{R}}}
   \end{bmatrix}
   \begin{bmatrix}
       \mathbf{\hat \delta_{\epsilon}'} \\
       \mathbf{\hat \delta_{\epsilon}''}
   \end{bmatrix} = 
   \begin{bmatrix}
       \mathbf{\hat b_{\mathcal{R}}} \\
       \mathbf{\hat b_{\mathcal{I}}}
   \end{bmatrix}

where each element of :math:`A` is evaluated by the following updated
formulation:

.. math::


       \begin{bmatrix}
           \{\mathbf{A_{\mathcal{R}}}\}_{m,n} \\
           \{\mathbf{A_{\mathcal{I}}}\}_{m,n}
       \end{bmatrix} = 
       \dfrac{\omega\epsilon_0}{I}
       \begin{bmatrix}
           \mathbf{e_{\mathcal{R},i}^n} & \mathbf{e_{\mathcal{I},i}^n} \\
           -\mathbf{e_{\mathcal{I},i}^n} & \mathbf{e_{\mathcal{R},i}^n}
       \end{bmatrix}^T
       \begin{bmatrix}
           -\mathbf{M_{\mathcal{I}}^n} & -\mathbf{M_{\mathcal{R}}^n} \\
           \mathbf{M_{\mathcal{R}}^n} & -\mathbf{M_{\mathcal{I}}^n}
       \end{bmatrix}
       \begin{bmatrix}
           \mathbf{e_{\mathcal{R},j}^n} \\
           -\mathbf{e_{\mathcal{I},j}^n}
       \end{bmatrix}

Here, :math:`M_i` and :math:`M_r`, :math:`A_i` and :math:`A_r`,
:math:`\delta_r` and :math:`\delta_i`, and :math:`b_r` and :math:`b_i`
are the real and imaginary parts of :math:`M`, :math:`A`, :math:`\delta`
and :math:`b`. The new system has twice the number of rows and columns.

Optimization Scheme
~~~~~~~~~~~~~~~~~~~

Once the inverse matrices are assembled, the residual is evaluated by
taking the L2 norm of the field error (and in case of just numerical
experiments, taking the norm of error in contrast is also possible).
This helps keep track of error in the reconstruction. This objective
function is iteratively solvable by many optimization methods, such as
Conjugate Gradient (where the derivative of the residual function will
be required), and some Quasi-Newton schemes.

Structure of the Library
========================

``MWInv`` attempts to program the entire functionality mentioned in the
previous section. It begins with the ``MWInvSystemSetup`` class that
takes user inputs for the physical system. This involves source and
receiver numbers, distance from the centre of the imaged region, source
waveform and frequencies, size of the imaged region and the maximum
region to simulate, and so on. These inputs are used to create a custom
mesh using the class ``DefaultMesh``, which creates a simple default
mesh using ``Gmsh`` that include the locations of the sources and
receivers.

The mesh and the user inputs now initialise the ``InverseSolve`` class,
which in turn initialises the ``ForwardSolve`` and ``OptimizeBase``
classes. ``ForwardSolve`` implements the FEM based forward solver based
on the mathematical formulation discussed above, using the mesh and user
inputs, and an initial estimate of the region's properties. ``MFEM``
allows for various configuration options on modifications to the default
solver settings. Its inputs are generally normalised, that allow for
much more versatility of problems solvable. GMRES is used to solve the
forward problem, and the electric field is obtained in all of imaging
region as the solution. This will require either one forward solve for
the simulatneous source imaging, or multiple solves for the individual
source switching.

Once solved, the matrices of the forward solver are used to assemble the
inverse linear system according to the steps mentioned above, as well as
the residual function and its derivatives. This requires elementwise
restructuring and assembly of the initial matrices. All of this is then
passed to the optimization scheme.

``OptiimzeBase`` currently only implements the Conjugate Gradient (CG)
scheme. This allows iterative update of the guess model, where after
each step, the new conjugate directions are evaluated by the use of
``dlib``\ 's CG funcionality. This allows updating the estimate model in
each iteration, where the ``ForwardSolve`` is called again, until
convergence or maximum iterations reached.

Evaluation
==========

My program does a lot of things, but it is incomplete. The
``MWInvSystemSetup`` classs could integrate all command line options and
streamline user input methods across all classes, but it is enough for
now, since several options from other classes are not compatible. The
meshing can be made more general purpose, but it is still extensible.
The ``ForwardSolve`` is clunky in design, but I could not do better,
even the examples from ``MFEM`` use quite large functions. The
``InverseSolve`` and related optimization classes are still just a
shell. Exports of data from the solutions need to be implemented too.
All in all, I did use features of C++ and tried making as general
purpose code as possible, but I could only test the forward solver and
meshing, not the inverse. I am quite dissapointed of this. Because of
how much time I spent just with the math and understanding the ``MFEM``
library, I could not do as well as I could hope for my own
implementation of the project.

Use Cases
=========

The library ideally implements functionality for a general-purpose
electromagnetic inversion algorithm. This means it can be used for any
inversion problem where the region of interest is imaged by
electromagnetic means. The major applications are in medical imaging and
geosciences. In medical imaging, imaging for dielectric properties of
different tissues in a living organism, for instance, to image the human
brain for detection of a brain stroke is a prominent application. In
geosciences, the subsurface is imaged using ground penetrating radars.
Non-invasive testing of materials is also possible to be conducted by
electromagnetic means, where this library will be useful. Some examples
of applications sourced from are illustrated as follows:

Outlook
=======

The library is a work in progress. Seamless integration of all three
extrenal libraries is required to allow the full potential of ``MFEM``,
and to make it really general-purpose. Aspects of contrast updating,
adaptive meshing and better design patterns need to be implemented for
faster, efficient code that utilises the full capabilites of ``MFEM``
and ``dlib`` solvers.

References
==========

.. [1] P. Lu and P. Kosmas, "Three-Dimensional Microwave Head Imaging with GPU-Based FDTD and the DBIM Method," Sensors, vol. 22, no. 7, pp. 2691, 2022. Available at: https://doi.org/10.3390/s22072691

.. [2] P. Lu, J. Córcoles, and P. Kosmas, "Enhanced FEM-based DBIM approach for two-dimensional microwave imaging," IEEE Transactions on Antennas and Propagation, vol. 69, no. 8, pp. 5187-5192, 2020. Available at: https://doi.org/10.1109/TAP.2021.3063659

.. [3] M. Pastorino, "Microwave imaging," John Wiley & Sons, 2010.

.. [4] P. van den Berg, "Forward and Inverse Scattering Algorithms based on Contrast Source Integral Equations," John Wiley & Sons, 2012.

.. [5] D. Davydov, T. V. Kolev, and P. S. Vassilevski, "MFEM: Modular Finite Element Methods for High-Performance Scientific Computing," SIAM Journal on Scientific Computing, vol. 40, no. 5, pp. C589-C623, 2018. Available at: https://doi.org/10.1137/17M1139350

.. [6] C. Geuzaine and J.-F. Remacle, "Gmsh: A three-dimensional finite element mesh generator with built-in pre- and post-processing facilities," International Journal for Numerical Methods in Engineering, vol. 79, no. 11, pp. 1309-1331, 2009. Available at: https://doi.org/10.1002/nme.2579

.. [7] D. E. King, "Dlib-ml: A machine learning toolkit," Journal of Machine Learning Research, vol. 10, pp. 1755-1758, 2009.

.. [8] MFEM: Modular Finite Element Methods for High-Performance Scientific Computing. Available at: https://mfem.org/

.. [9] Gmsh: A three-dimensional finite element mesh generator with built-in pre- and post-processing facilities. Available at: https://gmsh.info/

.. [10] Dlib: A machine learning toolkit. Available at: https://dlib.net/